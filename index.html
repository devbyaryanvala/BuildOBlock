<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>3D Block Builder</title>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: 'Press Start 2P', cursive;
            background-color: #333;
            color: #fff;
            display: flex;
            flex-direction: column;
            align-items: center;
            overscroll-behavior: none; /* Prevent pull-to-refresh or other browser gestures */
        }
        #game-container {
            width: 100vw;
            height: 100vh;
            position: relative;
        }
        canvas {
            display: block;
        }
        #controls-info { /* Desktop controls info */
            position: absolute;
            top: 10px;
            left: 10px;
            background-color: rgba(0,0,0,0.7);
            padding: 10px;
            border-radius: 8px;
            font-size: 12px;
            color: #fff;
            z-index: 10;
        }
        #crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 10px;
            height: 10px;
            border: 2px solid white;
            transform: translate(-50%, -50%);
            border-radius: 50%;
            mix-blend-mode: difference;
            z-index: 10;
            pointer-events: none; /* Make sure crosshair doesn't intercept touch/mouse */
        }
        .message-box {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 20px;
            border-radius: 10px;
            text-align: center;
            z-index: 100;
            display: none;
            font-size: 16px;
        }
        /* Desktop action buttons (bottom center) */
        .button-container {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 10px;
            z-index: 10;
        }
        .game-button { /* General style for all game buttons */
            background-color: #5cb85c;
            color: white;
            border: 2px solid #4cae4c;
            padding: 10px 15px;
            font-family: 'Press Start 2P', cursive;
            font-size: 14px;
            border-radius: 8px;
            cursor: pointer;
            box-shadow: 0 4px #3e8e41;
            transition: all 0.1s ease;
            user-select: none; /* Prevent text selection on tap */
            -webkit-user-select: none; /* Safari */
            -moz-user-select: none; /* Firefox */
            -ms-user-select: none; /* IE10+ */
            touch-action: manipulation; /* Improve touch responsiveness */
        }
        .game-button:active {
            box-shadow: 0 2px #3e8e41;
            transform: translateY(2px);
        }
        .game-button.remove {
            background-color: #d9534f;
            border-color: #d43f3a;
            box-shadow: 0 4px #b52b27;
        }
        .game-button.remove:active {
            box-shadow: 0 2px #b52b27;
        }

        /* Mobile Controls Container */
        #mobile-controls-container {
            position: fixed;
            bottom: 0;
            left: 0;
            width: 100%;
            height: auto;
            display: none; /* Hidden by default, shown for touch devices by JS */
            z-index: 20;
            box-sizing: border-box;
        }
        
        .mobile-d-pad {
            display: none; /* Hidden by default, shown by JS */
            grid-template-columns: repeat(3, 1fr);
            grid-template-rows: repeat(3, 1fr);
            gap: 5px;
            width: 150px; 
            height: 150px;
            position: fixed; 
            left: 20px;
            bottom: 30px;
        }

        .mobile-action-buttons {
            display: none; /* Hidden by default, shown by JS */
            grid-template-columns: repeat(2, 1fr); 
            gap: 10px;
            position: fixed; 
            right: 20px;
            bottom: 30px;
            width: auto; /* Adjust as needed based on button content */
        }
        
        .mobile-control-button {
            background-color: rgba(80, 80, 80, 0.7);
            color: white;
            border: 1px solid rgba(200, 200, 200, 0.8);
            font-size: 16px; 
            border-radius: 10px;
            padding: 12px; 
            text-align: center;
            user-select: none;
            -webkit-user-select: none;
            touch-action: manipulation;
            min-width: 60px; /* Ensure buttons have a minimum width */
        }
        .mobile-control-button:active {
            background-color: rgba(120, 120, 120, 0.9);
        }

        /* D-pad specific button placements */
        #move-forward-btn { grid-column: 2; grid-row: 1; } /* Up arrow on D-pad */
        #move-left-btn { grid-column: 1; grid-row: 2; }    /* Left arrow on D-pad */
        #move-backward-btn { grid-column: 2; grid-row: 3; }/* Down arrow on D-pad */
        #move-right-btn { grid-column: 3; grid-row: 2; }   /* Right arrow on D-pad */
        
        #mobile-status-info {
            position: fixed;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            background-color: rgba(0,0,0,0.6);
            padding: 8px 12px;
            border-radius: 6px;
            font-size: 12px;
            color: #fff;
            z-index: 10;
            text-align: center;
            display: none; /* Hidden by default, shown for touch by JS */
        }

    </style>
</head>
<body>
    <div id="game-container">
        <div id="controls-info"> <p>W/A/S/D: Move (W-Fwd, S-Back)</p> <p id="vertical-movement-text">Space: Jump / Shift: (Slow)</p>
            <p id="fly-toggle-text">F: Toggle Fly Mode (Currently OFF)</p>
            <p>Mouse: Look</p>
            <p>Click: Place Block</p>
            <p>Ctrl + Click / Right Click: Remove Block</p>
            <p>Scroll: Change Block Type</p>
            </div>
        <div id="mobile-status-info"> <span id="mobile-fly-status">Fly: OFF</span> | <span id="mobile-block-status">Block: Dirt</span>
        </div>

        <div id="crosshair"></div>
        <div id="message-box" class="message-box">Welcome!</div> <div class="button-container" id="desktop-button-container">
            <button id="addBlockBtnDesktop" class="game-button">Place Block</button>
            <button id="removeBlockBtnDesktop" class="game-button remove">Remove Block</button>
        </div>

        <div id="mobile-controls-container">
            <div class="mobile-d-pad" id="mobile-d-pad">
                <button id="move-forward-btn" class="mobile-control-button">▲</button>
                <button id="move-left-btn" class="mobile-control-button">◄</button>
                <button id="move-backward-btn" class="mobile-control-button">▼</button>
                <button id="move-right-btn" class="mobile-control-button">►</button>
            </div>
            <div class="mobile-action-buttons" id="mobile-action-buttons">
                <button id="jump-fly-up-btn" class="mobile-control-button">JUMP</button> <button id="crouch-fly-down-btn" class="mobile-control-button">CROUCH</button> <button id="toggle-fly-btn" class="mobile-control-button">FLY</button>
                <button id="place-block-btn-mobile" class="mobile-control-button">PLACE</button>
                <button id="remove-block-btn-mobile" class="mobile-control-button">DEL</button>
                <button id="next-block-btn-mobile" class="mobile-control-button">BLK+</button>
                <button id="prev-block-btn-mobile" class="mobile-control-button">BLK-</button>
            </div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/PointerLockControls.js"></script>

    <script>
        // Global Variables
        let scene, camera, renderer, controls;
        let objects = []; // Stores interactive blocks
        const worldSize = 30; // Size of the initial ground plane
        const cubeSize = 1; 

        // Player state
        let moveForward = false, moveBackward = false, moveLeft = false, moveRight = false;
        let moveUp = false, moveDown = false; 
        let canJump = false;    
        let isFlying = false;   
        let velocity = new THREE.Vector3(); 
        let direction = new THREE.Vector3(); 
        const playerSpeed = 50.0;    
        const verticalFlySpeed = 6.0; 
        const jumpHeight = 10.0;    
        const gravity = 30.0;       
        const playerHeight = 2.8;   
        const playerBoundingBox = new THREE.Box3(); 

        // Block types
        const blockTypes = [
            { color: 0x8B4513, name: 'Dirt' }, { color: 0x808080, name: 'Stone' }, { color: 0x228B22, name: 'Grass' },
            { color: 0xFFFF00, name: 'Sand' }, { color: 0xFF0000, name: 'Redstone' }, { color: 0x0000FF, name: 'Lapis' },
            { color: 0xFFFFFF, name: 'Snow' }, { color: 0x964B00, name: 'Wood' }, { color: 0x00FF00, name: 'Slime' },
            { color: 0xFFD700, name: 'Gold' }, { color: 0xC0C0C0, name: 'Iron' }, { color: 0x00FFFF, name: 'Diamond' },
            { color: 0x4B0082, name: 'Obsidian' }, { color: 0xA52A2A, name: 'Brick' }, { color: 0x696969, name: 'Coal' },
            { color: 0xF5DEB3, name: 'Planks' }, { color: 0x800000, name: 'Nether Brick' }, { color: 0x008080, name: 'Prismarine' },
            { color: 0xB22222, name: 'Magma' }, { color: 0xFF69B4, name: 'Pink Wool' }, { color: 0x40E0D0, name: 'Cyan Wool' },
            { color: 0x000000, name: 'Black Concrete' }, { color: 0xFFA500, name: 'Pumpkin' }, { color: 0xD2B48C, name: 'Sandstone' },
            { color: 0x191970, name: 'Blue Ice' }, { color: 0x006400, name: 'Dark Green Wool' }, { color: 0xDC143C, name: 'Crimson Nylium' },
            { color: 0x9932CC, name: 'Purpur Block' }, { color: 0x2F4F4F, name: 'Deepslate' }, { color: 0xE9967A, name: 'Terracotta' }
        ];
        let currentBlockTypeIndex = 0; 

        const raycaster = new THREE.Raycaster();
        const pointer = new THREE.Vector2(); // Normalized device coordinates for raycaster

        // DOM Elements
        const gameContainer = document.getElementById('game-container');
        const messageBox = document.getElementById('message-box');
        const controlsInfoDesktop = document.getElementById('controls-info');
        const mobileStatusInfo = document.getElementById('mobile-status-info');
        const mobileControlsContainer = document.getElementById('mobile-controls-container');
        const mobileDPad = document.getElementById('mobile-d-pad');
        const mobileActionButtons = document.getElementById('mobile-action-buttons');
        const desktopButtonContainer = document.getElementById('desktop-button-container');
        
        // Touch look variables
        // Adjust this value to change touch-look speed: higher = faster look, lower = slower.
        // Good values are typically between 0.001 and 0.005.
        let lookSensitivity = 0.001; 
        let lastTouchX = 0, lastTouchY = 0;
        let isTouchingToLook = false; 

        let prevTime; 
        const isTouchDevice = (('ontouchstart' in window) || (navigator.maxTouchPoints > 0) || (navigator.msMaxTouchPoints > 0));

        init();
        prevTime = performance.now(); // Initial time for the animation loop
        animate();
        updateCurrentBlockIndicator();
        updateFlyIndicator();

        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87CEEB); // Sky blue
            scene.fog = new THREE.Fog(0x87CEEB, 0, 150); // Fog for distance

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(worldSize / 2, playerHeight + 5, worldSize / 2 + 5); // Initial camera position

            renderer = new THREE.WebGLRenderer({ antialias: true }); // Enable anti-aliasing
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio); // Use device pixel ratio for sharpness
            renderer.shadowMap.enabled = true; 
            gameContainer.appendChild(renderer.domElement);

            controls = new THREE.PointerLockControls(camera, renderer.domElement);
            scene.add(controls.getObject()); // Add controls' object (camera parent) to scene

            messageBox.style.display = 'block';
            if (isTouchDevice) {
                messageBox.textContent = 'Tap screen to start & look. Use buttons to move/act.';
                controlsInfoDesktop.style.display = 'none'; 
                desktopButtonContainer.style.display = 'none'; 
                mobileStatusInfo.style.display = 'block';    
                mobileControlsContainer.style.display = 'block'; 
                mobileDPad.style.display = 'grid';             
                mobileActionButtons.style.display = 'grid';    
            } else {
                messageBox.textContent = 'Welcome! Click to start.';
                mobileControlsContainer.style.display = 'none';
                mobileStatusInfo.style.display = 'none';
                mobileDPad.style.display = 'none';
                mobileActionButtons.style.display = 'none';
            }

            setupInteractionListeners();

            // Lighting
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.7); 
            scene.add(ambientLight);
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.9); 
            directionalLight.position.set(70, 100, 80); 
            directionalLight.castShadow = true; 
            // Configure shadow properties for quality/performance
            directionalLight.shadow.mapSize.width = 1024; 
            directionalLight.shadow.mapSize.height = 1024;
            directionalLight.shadow.camera.near = 0.5;
            directionalLight.shadow.camera.far = 300;
            directionalLight.shadow.camera.left = -100;
            directionalLight.shadow.camera.right = 100;
            directionalLight.shadow.camera.top = 100;
            directionalLight.shadow.camera.bottom = -100;
            scene.add(directionalLight);

            // Ground plane
            const groundGeometry = new THREE.BoxGeometry(cubeSize, cubeSize, cubeSize);
            for (let x = 0; x < worldSize; x++) {
                for (let z = 0; z < worldSize; z++) {
                    const groundMaterial = new THREE.MeshLambertMaterial({ color: blockTypes[2].color }); // Grass
                    const cube = new THREE.Mesh(groundGeometry, groundMaterial);
                    cube.position.set(x * cubeSize, -cubeSize, z * cubeSize); // Position at y = -1
                    cube.castShadow = true;
                    cube.receiveShadow = true;
                    scene.add(cube);
                    objects.push(cube); 
                }
            }
            // Initial "terrain" variation
            for (let i = 0; i < 50; i++) { 
                addBlock({
                    x: Math.floor(Math.random() * worldSize) * cubeSize,
                    y: 0, // one level up
                    z: Math.floor(Math.random() * worldSize) * cubeSize
                }, Math.floor(Math.random() * 2)); // Dirt or Stone
            }

            document.addEventListener('keydown', onKeyDown); 
            document.addEventListener('keyup', onKeyUp);     
            window.addEventListener('mousedown', onGeneralMouseDown); 
            window.addEventListener('wheel', onMouseWheel);       
            window.addEventListener('resize', onWindowResize);    
            setupMobileButtonListeners(); 
        }

        function setupInteractionListeners() {
            if (isTouchDevice) {
                // Listener for touch-to-look
                renderer.domElement.addEventListener('touchstart', (event) => {
                    // Ignore if touch starts on a button
                    if (event.target.closest('.mobile-control-button, .game-button')) return;
                    
                    if (event.touches.length === 1) { // Single touch for looking
                        isTouchingToLook = true; 
                        lastTouchX = event.touches[0].clientX; 
                        lastTouchY = event.touches[0].clientY; 
                    }
                    if (messageBox.style.display !== 'none') {
                        messageBox.style.display = 'none';
                    }
                    event.preventDefault(); // Crucial: Prevent default browser touch actions
                }, { passive: false }); // `passive: false` needed for `preventDefault()`.

                renderer.domElement.addEventListener('touchmove', (event) => {
                    if (isTouchingToLook && event.touches.length === 1) {
                        const touchX = event.touches[0].clientX;
                        const touchY = event.touches[0].clientY;
                        const deltaX = touchX - lastTouchX; 
                        const deltaY = touchY - lastTouchY; 
                        lastTouchX = touchX; 
                        lastTouchY = touchY; 

                        const camObject = controls.getObject(); // Parent of the camera
                        
                        camObject.rotation.y -= deltaX * lookSensitivity; // Yaw
                        camera.rotation.x += deltaY * lookSensitivity; // Pitch (non-inverted Y)
                        
                        // Clamp pitch to prevent flipping
                        camera.rotation.x = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, camera.rotation.x));
                    }
                    event.preventDefault(); 
                }, { passive: false });

                renderer.domElement.addEventListener('touchend', (event) => {
                    if (event.touches.length === 0) { // All touches released
                        isTouchingToLook = false;
                    }
                });

            } else { // Desktop pointer lock
                gameContainer.addEventListener('click', () => {
                    if (!controls.isLocked) controls.lock(); 
                });
                controls.addEventListener('lock', () => { 
                    messageBox.style.display = 'none'; 
                    controlsInfoDesktop.style.display = 'block'; 
                });
                controls.addEventListener('unlock', () => { // e.g., Esc pressed
                    messageBox.textContent = 'Paused. Click to resume.';
                    messageBox.style.display = 'block'; 
                    controlsInfoDesktop.style.display = 'none'; 
                });
            }
        }
        
        function setupMobileButtonListeners() {
            // D-Pad Buttons (Press and hold)
            const dpadButtons = [
                { id: 'move-forward-btn', action: () => moveForward = true, stopAction: () => moveForward = false },
                { id: 'move-backward-btn', action: () => moveBackward = true, stopAction: () => moveBackward = false },
                { id: 'move-left-btn', action: () => moveLeft = true, stopAction: () => moveLeft = false },
                { id: 'move-right-btn', action: () => moveRight = true, stopAction: () => moveRight = false },
            ];
            dpadButtons.forEach(btnConfig => {
                const btnElement = document.getElementById(btnConfig.id);
                if(btnElement){
                    btnElement.addEventListener('touchstart', (e) => { e.preventDefault(); btnConfig.action(); }, { passive: false });
                    btnElement.addEventListener('touchend', (e) => { e.preventDefault(); btnConfig.stopAction(); }, { passive: false });
                    btnElement.addEventListener('touchcancel', (e) => { e.preventDefault(); btnConfig.stopAction(); }, { passive: false });
                }
            });

            // Vertical Movement Buttons (Press and hold)
            const verticalMovementButtons = [
                { id: 'jump-fly-up-btn', pressAction: handleJumpFlyUpPress, releaseAction: handleJumpFlyUpRelease },
                { id: 'crouch-fly-down-btn', pressAction: handleCrouchFlyDownPress, releaseAction: handleCrouchFlyDownRelease }
            ];
            verticalMovementButtons.forEach(config => {
                const btnElement = document.getElementById(config.id);
                if (btnElement) {
                    btnElement.addEventListener('touchstart', (e) => { e.preventDefault(); config.pressAction(); }, { passive: false });
                    btnElement.addEventListener('touchend', (e) => { e.preventDefault(); config.releaseAction(); }, { passive: false });
                    btnElement.addEventListener('touchcancel', (e) => { e.preventDefault(); config.releaseAction(); }, { passive: false });
                }
            });
            
            // Other Action Buttons (Single tap - 'touchstart' for quick response)
            const singleTapActionButtons = [
                { id: 'toggle-fly-btn', action: toggleFlyMode },
                { id: 'place-block-btn-mobile', action: attemptPlaceBlock },
                { id: 'remove-block-btn-mobile', action: attemptRemoveBlock },
                { id: 'next-block-btn-mobile', action: () => cycleBlockType(1) }, 
                { id: 'prev-block-btn-mobile', action: () => cycleBlockType(-1) }  
            ];
            singleTapActionButtons.forEach(config => {
                const btnElement = document.getElementById(config.id);
                if (btnElement) {
                    btnElement.addEventListener('touchstart', (e) => {
                        e.preventDefault(); // Prevent double-tap zoom etc.
                        config.action();    
                    }, { passive: false });
                }
            });
            
            // Desktop buttons (standard 'click')
            document.getElementById('addBlockBtnDesktop')?.addEventListener('click', (e) => {e.preventDefault(); if(controls.isLocked) attemptPlaceBlock();});
            document.getElementById('removeBlockBtnDesktop')?.addEventListener('click', (e) => {e.preventDefault(); if(controls.isLocked) attemptRemoveBlock();});
        }

        function handleJumpFlyUpPress() {
            if (isFlying) moveUp = true; 
            else if (canJump) { velocity.y += jumpHeight; canJump = false; } 
        }
        function handleJumpFlyUpRelease() { if(isFlying) moveUp = false; } 

        function handleCrouchFlyDownPress() { moveDown = true; } 
        function handleCrouchFlyDownRelease() { moveDown = false; }

        function toggleFlyMode() {
            isFlying = !isFlying;
            if (isFlying) { 
                velocity.y = 0; // Stop falling/rising
                canJump = false; // Cannot jump while flying
            }
            updateFlyIndicator(); 
        }
        
        function cycleBlockType(direction) { // direction: 1 for next, -1 for previous
            currentBlockTypeIndex = (currentBlockTypeIndex + direction + blockTypes.length) % blockTypes.length;
            updateCurrentBlockIndicator(); 
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function onKeyDown(event) { 
            if (!isTouchDevice && !controls.isLocked) return; // Desktop: only process if pointer locked
            
            switch (event.code) {
                case 'KeyW': moveForward = true; break;    // W for forward
                case 'KeyA': moveLeft = true; break;
                case 'KeyS': moveBackward = true; break;   // S for backward
                case 'KeyD': moveRight = true; break;
                case 'Space': handleJumpFlyUpPress(); break;
                case 'ShiftLeft': case 'ShiftRight': handleCrouchFlyDownPress(); break;
                case 'KeyF': toggleFlyMode(); break;
            }
        }

        function onKeyUp(event) {
            if (!isTouchDevice && !controls.isLocked) return; // Desktop: only process if pointer locked
             switch (event.code) {
                case 'KeyW': moveForward = false; break;
                case 'KeyA': moveLeft = false; break;
                case 'KeyS': moveBackward = false; break;
                case 'KeyD': moveRight = false; break;
                case 'Space': handleJumpFlyUpRelease(); break;
                case 'ShiftLeft': case 'ShiftRight': handleCrouchFlyDownRelease(); break;
            }
        }
        
        function updateFlyIndicator() {
            const flyStatusDesktop = document.getElementById('fly-toggle-text');
            const verticalMovementDesktop = document.getElementById('vertical-movement-text');
            const mobileFlyStatus = document.getElementById('mobile-fly-status');
            const jumpBtn = document.getElementById('jump-fly-up-btn');
            const crouchBtn = document.getElementById('crouch-fly-down-btn');

            let flyText = `Fly: ${isFlying ? 'ON' : 'OFF'}`;
            if (mobileFlyStatus) mobileFlyStatus.textContent = flyText;
            if (flyStatusDesktop) flyStatusDesktop.textContent = `F: Toggle Fly Mode (${isFlying ? 'ON' : 'OFF'})`;

            if (isFlying) {
                if (verticalMovementDesktop) verticalMovementDesktop.textContent = "Space: Ascend / Shift: Descend";
                if (jumpBtn) jumpBtn.textContent = "ASCEND";
                if (crouchBtn) crouchBtn.textContent = "DESCEND";
            } else {
                if (verticalMovementDesktop) verticalMovementDesktop.textContent = "Space: Jump / Shift: (Slow)";
                if (jumpBtn) jumpBtn.textContent = "JUMP";
                if (crouchBtn) crouchBtn.textContent = "CROUCH";
            }
        }

        function onGeneralMouseDown(event) { 
            if (isTouchDevice || !controls.isLocked) return; // Desktop only, pointer locked
            
            pointer.x = 0; // Raycast from screen center
            pointer.y = 0; 
            raycaster.setFromCamera(pointer, camera); 
            const intersects = raycaster.intersectObjects(objects, false); 

            if (intersects.length > 0) {
                const intersect = intersects[0]; // Closest intersected object
                if (event.button === 0 && (event.ctrlKey || event.metaKey)) { removeBlockAtIntersect(intersect); } // Ctrl/Cmd + Left click: remove
                else if (event.button === 0) { placeBlockAtIntersect(intersect); } // Left click: place
                else if (event.button === 2) { removeBlockAtIntersect(intersect); } // Right click: remove
            }
        }
        
        function attemptPlaceBlock() {
            if (!isTouchDevice && !controls.isLocked) return; // Desktop: require pointer lock
            
            pointer.x = 0; pointer.y = 0; // Raycast from screen center
            raycaster.setFromCamera(pointer, camera);
            const intersects = raycaster.intersectObjects(objects, false);
            if (intersects.length > 0) placeBlockAtIntersect(intersects[0]);
        }

        function attemptRemoveBlock() {
            if (!isTouchDevice && !controls.isLocked) return; 
            
            pointer.x = 0; pointer.y = 0; 
            raycaster.setFromCamera(pointer, camera);
            const intersects = raycaster.intersectObjects(objects, false);
            if (intersects.length > 0) removeBlockAtIntersect(intersects[0]);
        }

        function placeBlockAtIntersect(intersect) {
            const normal = intersect.face.normal.clone(); 
            // Calculate position for new block adjacent to clicked face
            const position = intersect.object.position.clone().add(normal.multiplyScalar(cubeSize));
            
            // Snap to grid
            position.x = Math.round(position.x / cubeSize) * cubeSize;
            position.y = Math.round(position.y / cubeSize) * cubeSize;
            position.z = Math.round(position.z / cubeSize) * cubeSize;

            // Check for existing block
            const blockExists = objects.some(obj => obj.position.distanceTo(position) < 0.1);
            if (blockExists) return; 

            // Check for player collision
            const playerPos = controls.getObject().position;
            const tempPlayerBox = new THREE.Box3().setFromCenterAndSize(
                playerPos, new THREE.Vector3(cubeSize * 0.8, playerHeight, cubeSize * 0.8) 
            );
            const newBlockBox = new THREE.Box3().setFromCenterAndSize(
                position, new THREE.Vector3(cubeSize, cubeSize, cubeSize) 
            );
            if (tempPlayerBox.intersectsBox(newBlockBox)) return; // Don't place block inside player
            
            addBlock(position, currentBlockTypeIndex); 
        }

        function addBlock(position, typeIndex) {
            const blockMaterial = new THREE.MeshLambertMaterial({ color: blockTypes[typeIndex].color });
            const blockGeometry = new THREE.BoxGeometry(cubeSize, cubeSize, cubeSize);
            const newCube = new THREE.Mesh(blockGeometry, blockMaterial);
            newCube.position.copy(position);
            newCube.castShadow = true; 
            newCube.receiveShadow = true;
            scene.add(newCube); 
            objects.push(newCube); 
        }

        function removeBlockAtIntersect(intersect) {
            // Prevent removing critical base ground blocks
            if (intersect.object.position.y === -cubeSize && objects.filter(obj => obj.position.y === -cubeSize).length <= 10) { 
                 return;
            }
             if (intersect.object.position.y < -cubeSize) return; // Safeguard

            scene.remove(intersect.object); 
            objects.splice(objects.indexOf(intersect.object), 1); 
            // Dispose geometry and material to free memory (important!)
            if (intersect.object.geometry) intersect.object.geometry.dispose();
            if (intersect.object.material) {
                if (Array.isArray(intersect.object.material)) intersect.object.material.forEach(m => m.dispose());
                else intersect.object.material.dispose();
            }
        }

        function onMouseWheel(event) { 
            if (isTouchDevice || !controls.isLocked) return;
            const scrollDelta = Math.sign(event.deltaY); 
            cycleBlockType(scrollDelta);
        }

        function updateCurrentBlockIndicator() {
            const blockTypeName = blockTypes[currentBlockTypeIndex].name;
            const blockTypeColorHex = `#${blockTypes[currentBlockTypeIndex].color.toString(16).padStart(6, '0')}`;
            
            const desktopInfo = document.getElementById('controls-info');
            let existingPDesktop = desktopInfo.querySelector('#current-block-text-desktop');
            if (existingPDesktop) existingPDesktop.remove(); 
            const pDesktop = document.createElement('p');
            pDesktop.id = 'current-block-text-desktop';
            pDesktop.textContent = `Selected: ${blockTypeName}`;
            pDesktop.style.color = blockTypeColorHex;
            desktopInfo.appendChild(pDesktop);

            const mobileBlockStatus = document.getElementById('mobile-block-status');
            if (mobileBlockStatus) {
                mobileBlockStatus.textContent = `Block: ${blockTypeName}`;
                mobileBlockStatus.style.color = blockTypeColorHex;
            }
        }

        function updatePlayer(delta) {
            // Only update if game is active (pointer locked on desktop; always on mobile after first interaction)
            if (!isTouchDevice && !controls.isLocked) { 
                 return;
            }

            velocity.x -= velocity.x * 10.0 * delta; // Damping (friction)
            velocity.z -= velocity.z * 10.0 * delta;

            if (isFlying) {
                velocity.y = 0; 
                if (moveUp) controls.getObject().position.y += verticalFlySpeed * delta; 
                if (moveDown) controls.getObject().position.y -= verticalFlySpeed * delta; 
                canJump = false; 
            } else {
                velocity.y -= gravity * delta; 
                controls.getObject().position.y += (velocity.y * delta); 
            }

            // Calculate movement direction
            // W/▲ = moveForward, S/▼ = moveBackward
            // A/◄ = moveLeft, D/► = moveRight
            direction.z = Number(moveForward) - Number(moveBackward); // + for forward, - for backward
            direction.x = Number(moveLeft) - Number(moveRight);       // + for left, - for right
            direction.normalize(); // Consistent speed diagonally

            // Adjust speed if crouching and not flying
            const currentSpeed = (moveDown && !isFlying) ? playerSpeed * 0.5 : playerSpeed; 

            // Apply horizontal velocity
            // Z (forward/backward):
            if (moveForward || moveBackward) velocity.z += direction.z * currentSpeed * delta; // CORRECTED: +=
            // X (left/right):
            if (moveLeft || moveRight) velocity.x -= direction.x * currentSpeed * delta; 


            controls.moveRight(velocity.x * delta);   // Positive velocity.x moves right
            controls.moveForward(velocity.z * delta); // Positive velocity.z moves forward

            // --- Basic Collision Detection & Resolution ---
            const playerPosition = controls.getObject().position;
            playerBoundingBox.setFromCenterAndSize(
                playerPosition,
                new THREE.Vector3(cubeSize * 0.7, playerHeight, cubeSize * 0.7) // Slightly smaller box for easier movement
            );
            
            let onObject = false; // Is player standing on an object?

            for (let i = 0; i < objects.length; i++) {
                const objectBox = new THREE.Box3().setFromObject(objects[i]); 
                if (playerBoundingBox.intersectsBox(objectBox)) { 
                    const intersection = new THREE.Box3().copy(playerBoundingBox).intersect(objectBox);
                    const overlapX = intersection.max.x - intersection.min.x;
                    const overlapY = intersection.max.y - intersection.min.y;
                    const overlapZ = intersection.max.z - intersection.min.z;

                    // Resolve collision by pushing player out
                    if (overlapY < overlapX && overlapY < overlapZ) { // Vertical collision smallest
                        if (isFlying) { // Simpler collision for flying
                            if (playerPosition.y > objectBox.getCenter(new THREE.Vector3()).y) { 
                                playerPosition.y = objectBox.max.y + playerHeight / 2 + 0.01; 
                            } else { 
                                playerPosition.y = objectBox.min.y - playerHeight / 2 - 0.01; 
                            }
                        } else { // Walking/Jumping collision
                            if (playerPosition.y > objectBox.max.y - playerHeight/2 + 0.05 && velocity.y <=0) { // Landed on top
                                playerPosition.y = objectBox.max.y + playerHeight / 2; 
                                velocity.y = 0; 
                                canJump = true; 
                                onObject = true;
                            } else if (playerPosition.y < objectBox.min.y + playerHeight/2 - 0.05 && velocity.y >=0) { // Hit head
                                playerPosition.y = objectBox.min.y - playerHeight / 2; 
                                velocity.y = 0; 
                            }
                        }
                    } else if (overlapX < overlapZ) { // Horizontal X collision smallest
                        if (playerPosition.x < objectBox.getCenter(new THREE.Vector3()).x) playerPosition.x -= overlapX; 
                        else playerPosition.x += overlapX; 
                        velocity.x = 0; 
                    } else { // Horizontal Z collision smallest
                        if (playerPosition.z < objectBox.getCenter(new THREE.Vector3()).z) playerPosition.z -= overlapZ; 
                        else playerPosition.z += overlapZ; 
                        velocity.z = 0; 
                    }
                    // Re-update player bounding box after resolution for subsequent checks
                    playerBoundingBox.setFromCenterAndSize(playerPosition, new THREE.Vector3(cubeSize * 0.7, playerHeight, cubeSize * 0.7));
                }
            }

            if (!isFlying) {
                if (!onObject && velocity.y < 0) canJump = false; // In air (falling/after jump peak), cannot jump
                
                // Prevent falling through void
                if (playerPosition.y < -50) { 
                     playerPosition.set(worldSize / 2, playerHeight + 10, worldSize / 2); 
                     velocity.y = 0; 
                     canJump = true; 
                }
            }
        }

        function animate() {
            requestAnimationFrame(animate); 

            const time = performance.now();
            const delta = (time - prevTime) / 1000; // Time delta in seconds
            
            if (isTouchDevice || controls.isLocked) { // Only update player if game active
                 updatePlayer(delta);
            }
            
            renderer.render(scene, camera); 
            prevTime = time; // Store time for next frame's delta
        }
    </script>
</body>
</html>
